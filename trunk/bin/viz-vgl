#!/usr/bin/env python

# VizStack - A Framework to manage visualization resources

# Copyright (C) 2009-2010 Hewlett-Packard
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
viz_vgl

VizStack support for using VirtualGL with VGL Image Transport.

So the user gets his desktop directly.
"""
import vsapi
from vsapi import ResourceAccess, Screen, GPU, Server, Keyboard, Mouse, VizResource, VizError
from pprint import pprint
from optparse import OptionParser, OptionGroup
import sys
import re
import time
import string
import socket
import os
import subprocess
import socket

parser = OptionParser(
usage= "usage: viz_vgl [options] [application args]",
description=
"""Runs an application using VirtualGL, using the VGL Image Transport if needed.  In this mode, the GUI of the application runs on the local X server while the OpenGL rendering happens on an allocated GPU.

You must execute this script either inside an X desktop session, or inside an SSH session with X11 forwarding enabled. This script will automatically pick up a GPU for you to use.  However, you may also choose a GPU by passing one/more of the options described below.

If the allocated GPU is on a different node, then this script uses VGL Image Transport with X11 Forwarding, over an SSH connection. If you haven't setup passwordless SSH, then you'll be prompted for a password.  The X11 traffic generated by the application passes via SSH, and is always encrypted.

The VirtualGL client program is started if the --x11-draw option is not specified. You may point the script to a running VirtualGL client by setting up the environment variables VGL_CLIENT and VGL_PORT to point to it.
""")
group = OptionGroup(parser, "Frequently used options")
group.add_option("-x", "--exclusive", dest="exclusive", action="store_true", default=False, help="Allocate a complete GPU for your use. By default, this script allocates a shared GPU for you. Use this flag to run applications that are expected to use a large percentage of GPU capabilities.")
group.add_option("-s", "--stereo", dest="use_stereo", action="store_true", default=False, help="Use this to run an application in stereo mode.  You may run an application in stereo, provided that the local X server is setup to enable Quad Buffered Stereo.")
group.add_option("--gpu-type", dest="gpu_type", help="Allocate a specific type of GPU for this remote session. Note that the GPU type will have spaces in it, so you will need to quote the string. Examples are \"Quadro FX 5800\", \"Quadro FX 1500\", etc. Use the --show-gpu-types option to print out a list of GPU types that may be potentially available.")
parser.add_option_group(group)
group = OptionGroup(parser, "Additional options")
group.add_option("--shell", dest="start_shell", action="store_true", default=False, help="Use this option to start a shell after allocating a GPU. You may use the 'vglrun' command inside this shell to run one/more OpenGL applications.")
group.add_option("-c", "--compress", dest="compress", action="store_true", default=False, help="Compress images using JPEG compression. By default, no compression is used. This option cannot be used with --x11-draw.")
group.add_option("-a", "--allocate-from", dest="allocate_from", action="append", help="Allocate a GPU on this hostname. If you use this option multiple times, then a single GPU from one of the specified hosts will be used. Note that the allocation is independent of the order in which the hostnames are specified on the command line.")
group.add_option("--secure", dest="secure", action="store_true", default=False, help="By default the application's image stream is left unencrypted. This results in maximum performance. Using this option will encrypt the images using SSL, thereby reducing performance.  Enable this if you want absolute security. Also note that this option only takes effect if the allocated GPU is on a different node compared to where this script runs.")
group.add_option("--x11-draw", dest="x11_draw", action="store_true", default=False, help="Use this option if are unable to use the VirtualGL client on your local X server. This will force VirtualGL to send uncompressed 3D images directly to your X server. Using this option will typically result in lower performance.")
group.add_option("--show-gpu-types", dest="show_gpu_types", action="store_true", default=False, help="Prints out a list of GPU types that are potentially available for allocation")
parser.add_option_group(group)
(options, args) = parser.parse_args(sys.argv[1:])

# Extra arguments are errors.
if len(args)==0 and (options.show_gpu_types == False):
	if options.start_shell==False:
		print >>sys.stderr # empty line
		print >>sys.stderr, "Please specify a command to run"
		print >>sys.stderr # empty line
		parser.print_help()
		sys.exit(-1)

if (options.x11_draw == True) and (options.compress == True):
	print >>sys.stderr, "ERROR: The options --x11-draw and --compress are exclusive"
	sys.exit(-1)

# If stereo is asked for, then ask for an exclusive GPU automatically
if options.use_stereo:
	options.exclusive = True

# Check the DISPLAY environment variable
try:
	os.environ['DISPLAY']
except KeyError, e:
	print >>sys.stderr, "You must set the DISPLAY environment variable to your X display. This will be used to run your application with 'vglrun'"
	sys.exit(-1)

# Connect to the SSM
try:
	ra = ResourceAccess()
except VizError, e:
	print >>sys.stderr, "%s"%(str(e))
	sys.exit(-1)

# If we have a need to get the type of GPUs, then do so
if (options.show_gpu_types == True) or (options.gpu_type is not None):
	gpuList = ra.queryResources(vsapi.GPU())
	# Compute how many of which type are present
	gpuTypeInfo = {}
	for gpu in gpuList:
		gpuType = gpu.getType()
		try:
			gpuTypeInfo[gpuType] += 1
		except KeyError:
			gpuTypeInfo[gpuType] = 1

	if options.show_gpu_types == True:
		# If the user only asked us to print out GPU type information,
		# then we print it out
		for gpuType in gpuTypeInfo.keys():
			# FIXME: should I print out information about how many are free at this instant ?
			print "GPU type '%s', total available in system = %d"%(gpuType, gpuTypeInfo[gpuType])
		# Disconnect from the SSM
		ra.stop()
		# Exit with sucess
		sys.exit(0)

	if options.gpu_type is not None:
		if not gpuTypeInfo.has_key(options.gpu_type):
			print >>sys.stderr
			print >>sys.stderr, "Invalid GPU type '%s' passed on the command line.\nA valid value is one of %s.\nNote that you need to quote the string when running this script from the shell."%(options.gpu_type, gpuTypeInfo.keys())
			print >>sys.stderr
			sys.exit(-1)

# Validate the host list if user asked for specific hosts
# This helps us print messages that make more sense for the
# user
if options.allocate_from is not None:
	# Get a list of all hostnames from the SSM
	nodeList = ra.queryResources(vsapi.VizNode())
	validHostList = []
	for node in nodeList:
		validHostList.append(node.getHostName())

	# Find out what's not valid
	invalidHostNames = filter(lambda x: x not in validHostList, options.allocate_from)

	# And print them out
	if len(invalidHostNames)>0:
		print >>sys.stderr
		print >>sys.stderr, "The following hostname(s) specified on the command line are invalid\n%s"%(invalidHostNames)
		print >>sys.stderr
		print >>sys.stderr, "Please ensure that they are indeed part of this system."
		print >>sys.stderr
		sys.exit(-1)
	
# Allocate resources needed
try:
	# We'll need a GPU
	reqGPU = vsapi.GPU()
	if options.gpu_type is not None:
		reqGPU.setType(options.gpu_type)

	if options.allocate_from is None:
		potentialHostList = []
	else:
		potentialHostList = options.allocate_from

	# Stereo needs a GPU with scanout and stereo caps
	if options.use_stereo == True:
		reqGPU.setUseScanOut(True)
		reqGPU.setAllowStereo(True)

	# Make a resource list with resources we need
	if options.exclusive:
		# Allocate am X server and a GPU
		reqList = [ reqGPU, vsapi.Server() ]
	else:
		# Allocate a shared GPU. X server will come from the GPU
		reqGPU.setShared(True)
		reqList = [ reqGPU ]

	# Allocate needed resources
	alloc = ra.allocate([
		  reqList
		],
		potentialHostList
	)
except vsapi.VizError, e:
	print >>sys.stderr, "Unable to allocate resources needed for a rendering using VirtualGL."
	print >>sys.stderr, "Reason: %s"%(str(e))
	print >>sys.stderr
	print >>sys.stderr, "Please try again later"
	sys.exit(-1)

# Get the allocated resources
allocRes = alloc.getResources()
gpu = allocRes[0][0]
if options.exclusive:
	xServer = allocRes[0][1]
else:
	xServer = gpu.getSharedServer()

# Setup the X server
scr = Screen(0)
# If enabled, then the GPU also needs to be configured for stereo
# We configure a 110 Hz active CRT stereo display.
# FIXME: If the stereo display is attached, then the display signals
# generated might activate the display. Since this is TurboVNC, there
# is no security related problem unless someone draws on the frame buffer
#
# We could eliminate this by creating a phony DVI device which
# runs active stereo at some refresh rate which no DVI device will use!?
#
if options.use_stereo == True:
	gpu.setScanout(port_index=0, display_device="Generic Stereo CRT", mode="1280x1024_110")
	scr.setFBProperty('stereo', 'active')
else:
	if gpu.getAllowNoScanOut():
		# VirtualGL uses a pbuffer anyway, so we choose a small resolution
		# virtual framebuffer
		gpu.clearScanouts()
		scr.setFBProperty('resolution',[640,480])
	else:
		# Configure a dummy display if no display is connected
		# already. Needed for GeForce GPUs to work.
		if len(gpu.getScanouts())==0:
			sc = gpu.getScanoutCaps()
			gpu.setScanout(0, 'HP LP2065', sc[0][0])
scr.setGPU(gpu)
xServer.addScreen(scr)

# Propagate the X server settings to the SSM
alloc.setupViz(ra)

# Start the X server
alloc.startViz(ra)

vglNode = xServer.getHostName()

vglRunEnv = []
# Use the VGL client if not using direct X11 drawing
if not options.x11_draw:
	try:
		vglClientHost = os.environ['VGL_CLIENT']
	except:
		vglClientHost = None

	if vglClientHost is not None:
		try:
			vglClientPort = int(os.environ['VGL_PORT'])
		except:
			# assume default client port
			vglClientPort = 4242

	if not vglClientHost:

		# We use the vglclient if the allocated GPU is on the same
		# node as us. Why ?
		#
		# I have observed that using x11_draw is slower than using
		# the vglclient for rendering. A possible reason for this is
		# that the vglclient uses faster pixel drawing methods - e.g.
		# OpenGL.

		# Start the VGL client on the local machine
		# The VGL client will print the port number where the VGL client is listening
		# If a VGL client is already running on the local machine, then it will 
		# print out the port number of the running client and exit
		#
		# One potential issue with this approach is that the vglclient program keeps
		# running even when the script exits. We allow this behaviour to remain. If
		# we killed the vglclient, then two or more instances of this script can't
		# run at the same time.
		#
		# A vglclient instance is associated with an X server, so this is not a problem
		# with multiple vglclients running on different X servers, potentially for one/more
		# users.
		#

		vglClientProc = subprocess.Popen(['/opt/VirtualGL/bin/vglclient', '-detach'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		outMsg, errMsg = vglClientProc.communicate()
		vglClientProc.wait()

		vglClientHost = xServer.getHostName()
		try:
			vglClientPort = int(outMsg.lstrip().rstrip())
			print 'VirtualGL client running on host %s, port %d'%(vglClientHost, vglClientPort)
		except:
			# The vglclient segfaulted on Ubuntu, so I put in this.
			# FIXME: quad buffered stereo rendering will fail there is no client. Should
			# we terminate app in this case?
			print 'Failed to start VGL client'
			vglClientHost = vglClientPort = None
	else:
		print 'VirtualGL client assumed to be running on host %s port %d'%(vglClientHost, vglClientPort)

	if vglClientHost is not None:
		# Contribute to environment setup
		vglRunEnv = ["VGL_CLIENT=%s"%(vglClientHost), "VGL_PORT=%s"%(vglClientPort)]

if vglNode not in [ "localhost", socket.gethostname()]:
	# Use SSH 
	cmdArgs = ["ssh", "-X", xServer.getHostName()]
	otherMachine = True

	# If security is asked for, enable SSL with VGL
	if options.secure == True:
		vglRunEnv += ["VGL_SSL=1"]
else:
	cmdArgs = []
	otherMachine = False

vglRunEnv += ["VGL_DISPLAY=%s"%(xServer.getDISPLAY())]

# Enable stereo if asked for
if options.use_stereo == True:
	vglRunEnv += ["VGL_STEREO=quad"]

if options.x11_draw == True:
	# Use proxy drawing if explicitly asked for
	# FIXME: should we fail usage of stereo with this ?
	# vglrun autonatically uses anaglyphic stereo if
	# the virtualgl client is not used
	vglRunEnv += ["VGL_COMPRESS=proxy"]
elif (otherMachine == True) and (vglClientHost is not None):
	# Use the VGL image transport only if we know that the
	# client is running
	if options.compress == True:
		vglRunEnv += ["VGL_COMPRESS=jpeg"]
	else:
		vglRunEnv += ["VGL_COMPRESS=rgb"]

if os.environ.has_key('DISPLAY'):
	vglRunEnv += ["DISPLAY=%s"%(os.environ["DISPLAY"])]

# Start a shell or use vglrun as appropriate
if options.start_shell == True:
	args = ["/bin/bash"]
	if otherMachine:
		args += ["-login"]
	print "Allocated GPU %d controlled by X Server '%s' on host '%s' for you."%(gpu.getIndex(), xServer.getDISPLAY(), xServer.getHostName())
	if (vglNode != "localhost") and (vglNode != socket.gethostname()):
		print "Starting secure shell to host '%s'..."%(xServer.getHostName())
	else:
		print "Starting shell..."
	print
	print "When you exit this shell, the GPU will be freed for use by others."
	print "Inside this shell, please use \"vglrun\" to run your OpenGL application."
	print
	shellArgs = []
else:
	args = ["/usr/bin/vglrun"]+args
	shellArgs = ["/opt/vizstack/bin/vs-aew"]
	print "Running application '%s' on host '%s', gpu %d, server %s"%(string.join(args," "), xServer.getHostName(), gpu.getIndex(), xServer.getDISPLAY())

# Run the command needed
overallCmd = cmdArgs + shellArgs + [ "/usr/bin/env" ] + vglRunEnv + args

os.system(string.join(overallCmd," "))

if options.start_shell == True:
	print "Cleaning up..."

# Stop the real X server - this is not needed actually
alloc.stopViz(ra)

# Deallocate resources. We do this quickly to prevent GDM from keeping running!
ra.deallocate(alloc)

# Disconnect from the SSM - we're done!
ra.stop()
