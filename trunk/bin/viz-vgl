#!/usr/bin/env python

# VizStack - A Framework to manage visualization resources
# Copyright (C) 2009  name of Shreekumar <shreekumar/at/users.sourceforge.net>
# Copyright (C) 2009  name of Manjunath Sripadarao <manjunaths/at/users.sourceforge.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


"""
viz_vgl

VizStack support for using VirtualGL with VGL Image Transport.

So the user gets his desktop directly.
"""
import vsapi
from vsapi import ResourceAccess, Screen, GPU, Server, Keyboard, Mouse, VizResource, VizError
from pprint import pprint
from optparse import OptionParser, OptionGroup
import sys
import re
import time
import string
import socket
import os
import subprocess
import socket

parser = OptionParser(
usage= "usage: viz_vgl [options] [application args]",
description=
"""Runs an application using VirtualGL, using the VGL Image Transport if needed.  In this mode, the GUI of the application runs on the local X server while the OpenGL rendering happens on an allocated GPU.

You must execute this script either inside an X desktop session, or inside an SSH session with X11 forwarding enabled. This script will automatically pick up a GPU for you to use.  However, you may also choose a GPU by passing one/more of the options described below.

If the allocated GPU is on a different node, then this script uses VGL Image Transport with X11 Forwarding, over an SSH connection. If you haven't setup passwordless SSH, then you'll be prompted for a password.  The X11 traffic generated by the application passes via SSH, and is always encrypted.
""")
group = OptionGroup(parser, "Frequently used options")
group.add_option("-s", "--stereo", dest="use_stereo", action="store_true", default=False, help="Use this to run an application in stereo mode.  You may run an application in stereo, provided that the local X server is setup to enable Quad Buffered Stereo.")
group.add_option("--gpu-type", dest="gpu_type", help="Allocate a specific type of GPU for this remote session. Note that the GPU type will have spaces in it, so you will need to quote the string. Examples are \"Quadro FX 5800\", \"Quadro FX 1500\", etc. Use the --show-gpu-types option to print out a list of GPU types that may be potentially available.")
parser.add_option_group(group)
group = OptionGroup(parser, "Additional options")
group.add_option("--shell", dest="start_shell", action="store_true", default=False, help="Use this option to start a shell after allocating a GPU. You may use the 'vglrun' command inside this shell to run one/more OpenGL applications.")
group.add_option("-c", "--compress", dest="compress", action="store_true", default=False, help="Compress images using JPEG compression. By default, no compression is used. This option cannot be used with --x11-draw.")
group.add_option("-a", "--allocate-from", dest="allocate_from", action="append", help="Allocate a GPU on this hostname. If you use this option multiple times, then a single GPU from one of the specified hosts will be used. Note that the allocation is independent of the order in which the hostnames are specified on the command line.")
group.add_option("--secure", dest="secure", action="store_true", default=False, help="By default the application's image stream is left unencrypted. This results in maximum performance. Using this option will encrypt the images using SSL, thereby reducing performance.  Enable this if you want absolute security. Also note that this option only takes effect if the allocated GPU is on a different node compared to where this script runs.")
group.add_option("--x11-draw", dest="x11_draw", action="store_true", default=False, help="Use this option if are unable to use the VirtualGL client on your local X server. This will force VirtualGL to send uncompressed 3D images directly to your X server. Using this option will typically result in lower performance.")
group.add_option("--show-gpu-types", dest="show_gpu_types", action="store_true", default=False, help="Prints out a list of GPU types that are potentially available for allocation")
parser.add_option_group(group)
(options, args) = parser.parse_args(sys.argv[1:])

# Extra arguments are errors.
if len(args)==0 and (options.show_gpu_types == False):
	if options.start_shell==False:
		print >>sys.stderr # empty line
		print >>sys.stderr, "Please specify a command to run"
		print >>sys.stderr # empty line
		parser.print_help()
		sys.exit(-1)

if (options.x11_draw == True) and (options.compress == True):
	print >>sys.stderr, "ERROR: The options --x11-draw and --compress are exclusive"
	sys.exit(-1)

# Check the DISPLAY environment variable
try:
	os.environ['DISPLAY']
except KeyError, e:
	print >>sys.stderr, "You must set the DISPLAY environment variable to your X display. This will be used to run your application with 'vglrun'"
	sys.exit(-1)

# Connect to the SSM
try:
	ra = ResourceAccess()
except VizError, e:
	print >>sys.stderr, "%s"%(str(e))
	sys.exit(-1)

# If we have a need to get the type of GPUs, then do so
if (options.show_gpu_types == True) or (options.gpu_type is not None):
	gpuList = ra.queryResources(vsapi.GPU())
	# Compute how many of which type are present
	gpuTypeInfo = {}
	for gpu in gpuList:
		gpuType = gpu.getType()
		try:
			gpuTypeInfo[gpuType] += 1
		except KeyError:
			gpuTypeInfo[gpuType] = 1

	if options.show_gpu_types == True:
		# If the user only asked us to print out GPU type information,
		# then we print it out
		for gpuType in gpuTypeInfo.keys():
			# FIXME: should I print out information about how many are free at this instant ?
			print "GPU type '%s', total available in system = %d"%(gpuType, gpuTypeInfo[gpuType])
		# Disconnect from the SSM
		ra.stop()
		# Exit with sucess
		sys.exit(0)

	if options.gpu_type is not None:
		if not gpuTypeInfo.has_key(options.gpu_type):
			print >>sys.stderr
			print >>sys.stderr, "Invalid GPU type '%s' passed on the command line.\nA valid value is one of %s.\nNote that you need to quote the string when running this script from the shell."%(options.gpu_type, gpuTypeInfo.keys())
			print >>sys.stderr
			sys.exit(-1)

# Validate the host list if user asked for specific hosts
# This helps us print messages that make more sense for the
# user
if options.allocate_from is not None:
	# Get a list of all hostnames from the SSM
	nodeList = ra.queryResources(vsapi.VizNode())
	validHostList = []
	for node in nodeList:
		validHostList.append(node.getHostName())

	# Find out what's not valid
	invalidHostNames = filter(lambda x: x not in validHostList, options.allocate_from)

	# And print them out
	if len(invalidHostNames)>0:
		print >>sys.stderr
		print >>sys.stderr, "The following hostname(s) specified on the command line are invalid\n%s"%(invalidHostNames)
		print >>sys.stderr
		print >>sys.stderr, "Please ensure that they are indeed part of this system."
		print >>sys.stderr
		sys.exit(-1)
	
# Allocate resources needed
try:
	# We'll need a GPU
	reqGPU = vsapi.GPU()
	if options.gpu_type is not None:
		reqGPU.setType(options.gpu_type)

	if options.allocate_from is None:
		potentialHostList = []
	else:
		potentialHostList = options.allocate_from

	# Stereo needs a GPU with scanout
	if options.use_stereo == True:
		reqGPU.setUseScanOut(True)

	# Allocate the X server and a GPU
	alloc = ra.allocate([
		  [ vsapi.Server(), reqGPU ]	
		],
		potentialHostList
	)
except vsapi.VizError, e:
	print >>sys.stderr, "Unable to allocate resources needed for a HP RGS desktop session."
	print >>sys.stderr, "Reason: %s"%(str(e))
	print >>sys.stderr
	print >>sys.stderr, "Please try again later"
	sys.exit(-1)

# Get the allocated resources
allocRes = alloc.getResources()
xServer = allocRes[0][0]
gpu = allocRes[0][1]

# Setup the X server
scr = Screen(0)
# If enabled, then the GPU also needs to be configured for stereo
# We configure a 110 Hz active CRT stereo display.
# FIXME: If the stereo display is attached, then the display signals
# generated might activate the display. Since this is TurboVNC, there
# is no security related problem unless someone draws on the frame buffer
#
# We could eliminate this by creating a phony DVI device which
# runs active stereo at some refresh rate which no DVI device will use!?
#
if options.use_stereo == True:
	gpu.setScanout(port_index=0, display_device="GenericStereoCRT", mode="1280x1024_110")
	scr.setFBProperty('stereo', 'active')
else:
	scr.setFBProperty('resolution',[640,480]) # VirtualGL uses a pbuffer anyway, so we choose a small resolution...
scr.setGPU(gpu)
xServer.addScreen(scr)

# Propagate the X server settings to the SSM
alloc.setupViz(ra)

# Start the X server
alloc.startViz(ra)

vglNode = xServer.getHostName()

# Use the VGL client only if the GPU is not on the same node as us
if (vglNode != "localhost") and (vglNode != socket.gethostname()):
	# Start the VGL client on the local machine
	# The VGL client will print the port number where the VGL client is listening
	# If a VGL client is already running on the local machine, then it will 
	# print out the port number of the running client and exit
	#
	# One potential issue with this approach is that the vglclient program keeps
	# running even when the script exits. We allow this behaviour to remain. If
	# we killed the vglclient, then two or more instances of this script can't
	# run at the same time.
	#
	# A vglclient instance is associated with an X server, so this is not a problem
	# with multiple vglclients running on different X servers, potentially for one/more
	# users.
	#

	vglClientProc = subprocess.Popen(['/opt/VirtualGL/bin/vglclient', '-detach'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
	outMsg, errMsg = vglClientProc.communicate()
	vglClientProc.wait()

	vglRunEnv = ["VGL_CLIENT=%s"(xServer.getHostName()), "VGL_PORT=%s"(outMsg.lstrip().rstrip())]
	if options.secure == True:
		vglRunEnv += ["VGL_SSL=1"]

	# Use SSH if needed
	cmdArgs = ["ssh", "-X", xServer.getHostName()]
	otherMachine = True
else:
	vglRunEnv = []
	cmdArgs = []
	otherMachine = False

vglRunEnv += ["VGL_DISPLAY=%s"%(xServer.getDISPLAY())]

# Enable stereo if asked for
if options.use_stereo == True:
	vglRunEnv += ["VGL_STEREO=quad"]

if options.x11_draw == True:
	vglRunEnv += ["VGL_COMPRESS=proxy"]
elif options.compress == True:
	vglRunEnv += ["VGL_COMPRESS=jpeg"]
else:
	vglRunEnv += ["VGL_COMPRESS=rgb"]
	
# Start a shell or use vglrun as appropriate
if options.start_shell == True:
	args = ["/bin/bash"]
	if otherMachine:
		args += ["-login"]
	print "Allocated GPU %d controlled by X Server '%s' on host '%s' for you."%(gpu.getIndex(), xServer.getDISPLAY(), xServer.getHostName())
	if (vglNode != "localhost") and (vglNode != socket.gethostname()):
		print "Starting secure shell to host '%s'..."%(xServer.getHostName())
	else:
		print "Starting shell..."
	print
	print "When you exit this shell, the GPU will be freed for use by others."
	print "Inside this shell, please use \"vglrun\" to run your OpenGL application."
	print
	shellArgs = []
else:
	args = ["/usr/bin/vglrun"]+args
	shellArgs = ["/opt/vizstack/bin/vs-aew"]
	print "Running application '%s' on host '%s', gpu %d, server %s"%(string.join(args," "), xServer.getHostName(), gpu.getIndex(), xServer.getDISPLAY())

# Run the command needed
overallCmd = cmdArgs + shellArgs + [ "/usr/bin/env" ] + vglRunEnv + args

os.system(string.join(overallCmd," "))

if options.start_shell == True:
	print "Cleaning up..."

# Stop the real X server - this is not needed actually
alloc.stopViz(ra)

# Deallocate resources. We do this quickly to prevent GDM from keeping running!
ra.deallocate(alloc)

# Disconnect from the SSM - we're done!
ra.stop()
